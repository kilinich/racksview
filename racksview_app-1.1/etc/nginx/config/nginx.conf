
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    server {
        listen       80;  # Change to 443 for HTTPS if needed
        server_name  racksview;  # Replace with your actual hostname or localhost

        # Serve static files at root (/)
        location / {
            root   html;  # Assumes files are in /usr/local/openresty/nginx/html/
            index  index.html;
        }

        # Proxy raw TCP MJPEG stream with added HTTP headers at /stream1
        location /stream1 {
            content_by_lua_block {
                -- Set HTTP response headers for MJPEG streaming
                ngx.status = 200
                ngx.header.content_type = "multipart/x-mixed-replace; boundary=--ThisRandomString"
                ngx.header["Cache-Control"] = "no-cache"
                ngx.header["Pragma"] = "no-cache"
                ngx.header["Connection"] = "close"  -- Optional: Helps with connection management

                -- Create and connect TCP socket to GStreamer stream
                local sock = ngx.socket.tcp()
                local ok, err = sock:connect("127.0.0.1", 8013)
                if not ok then
                    ngx.log(ngx.ERR, "Failed to connect to TCP stream: ", err)
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                -- Stream data in chunks, flushing to client for real-time delivery
                while true do
                    local data, err, partial = sock:receive(4096)  -- Buffer size; adjust for your stream (e.g., 8192 for higher bandwidth)
                    if data then
                        ngx.print(data)
                        ngx.flush(true)
                    elseif partial then
                        ngx.print(partial)
                        ngx.flush(true)
                    else
                        if err == "closed" then
                            break
                        else
                            ngx.log(ngx.ERR, "Error receiving from TCP stream: ", err)
                            break
                        end
                    end
                end

                -- Clean up
                sock:close()
            }
        }
        # Proxy raw TCP MJPEG stream with added HTTP headers at /stream2
        location /stream2 {
            content_by_lua_block {
                -- Set HTTP response headers for MJPEG streaming
                ngx.status = 200
                ngx.header.content_type = "multipart/x-mixed-replace; boundary=--ThisRandomString"
                ngx.header["Cache-Control"] = "no-cache"
                ngx.header["Pragma"] = "no-cache"
                ngx.header["Connection"] = "close"  -- Optional: Helps with connection management

                -- Create and connect TCP socket to GStreamer stream
                local sock = ngx.socket.tcp()
                local ok, err = sock:connect("127.0.0.1", 8012)
                if not ok then
                    ngx.log(ngx.ERR, "Failed to connect to TCP stream: ", err)
                    return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                end

                -- Stream data in chunks, flushing to client for real-time delivery
                while true do
                    local data, err, partial = sock:receive(4096)  -- Buffer size; adjust for your stream (e.g., 8192 for higher bandwidth)
                    if data then
                        ngx.print(data)
                        ngx.flush(true)
                    elseif partial then
                        ngx.print(partial)
                        ngx.flush(true)
                    else
                        if err == "closed" then
                            break
                        else
                            ngx.log(ngx.ERR, "Error receiving from TCP stream: ", err)
                            break
                        end
                    end
                end

                -- Clean up
                sock:close()
            }
        }
        location /events/ {
            alias /opt/racksview/events/;
            autoindex on;
            add_before_body /downloads.css;
            add_after_body /disable-top.js;
            autoindex_exact_size off;  # Optional: Use human-readable file sizes (e.g., KB/MB)
        }
    }
}